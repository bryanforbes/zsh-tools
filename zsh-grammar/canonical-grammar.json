{
  "$schema": "./canonical-grammar.schema.json",
  "languages": {
    "core": {
      "SEPER": {
        "token": "SEPER",
        "matches": ";",
        "source": {
          "file": "zsh.h",
          "line": 316
        }
      },
      "NEWLIN": {
        "token": "NEWLIN",
        "matches": "\\\\n",
        "source": {
          "file": "zsh.h",
          "line": 317
        }
      },
      "SEMI": {
        "token": "SEMI",
        "matches": ";",
        "source": {
          "file": "zsh.h",
          "line": 318
        }
      },
      "DSEMI": {
        "token": "DSEMI",
        "matches": ";;",
        "source": {
          "file": "zsh.h",
          "line": 319
        }
      },
      "AMPER": {
        "token": "AMPER",
        "matches": "&",
        "source": {
          "file": "zsh.h",
          "line": 320
        }
      },
      "INPAR": {
        "token": "INPAR",
        "matches": "(",
        "source": {
          "file": "zsh.h",
          "line": 321
        }
      },
      "OUTPAR": {
        "token": "OUTPAR",
        "matches": ")",
        "source": {
          "file": "zsh.h",
          "line": 322
        }
      },
      "DBAR": {
        "token": "DBAR",
        "matches": "||",
        "source": {
          "file": "zsh.h",
          "line": 323
        }
      },
      "DAMPER": {
        "token": "DAMPER",
        "matches": "&&",
        "source": {
          "file": "zsh.h",
          "line": 324
        }
      },
      "OUTANG": {
        "token": "OUTANG",
        "matches": ">",
        "source": {
          "file": "zsh.h",
          "line": 325
        }
      },
      "OUTANGBANG": {
        "token": "OUTANGBANG",
        "matches": ">|",
        "source": {
          "file": "zsh.h",
          "line": 326
        }
      },
      "DOUTANG": {
        "token": "DOUTANG",
        "matches": ">>",
        "source": {
          "file": "zsh.h",
          "line": 327
        }
      },
      "DOUTANGBANG": {
        "token": "DOUTANGBANG",
        "matches": ">>|",
        "source": {
          "file": "zsh.h",
          "line": 328
        }
      },
      "INANG": {
        "token": "INANG",
        "matches": "<",
        "source": {
          "file": "zsh.h",
          "line": 329
        }
      },
      "INOUTANG": {
        "token": "INOUTANG",
        "matches": "<>",
        "source": {
          "file": "zsh.h",
          "line": 330
        }
      },
      "DINANG": {
        "token": "DINANG",
        "matches": "<<",
        "source": {
          "file": "zsh.h",
          "line": 331
        }
      },
      "DINANGDASH": {
        "token": "DINANGDASH",
        "matches": "<<-",
        "source": {
          "file": "zsh.h",
          "line": 332
        }
      },
      "INANGAMP": {
        "token": "INANGAMP",
        "matches": "<&",
        "source": {
          "file": "zsh.h",
          "line": 333
        }
      },
      "OUTANGAMP": {
        "token": "OUTANGAMP",
        "matches": ">&",
        "source": {
          "file": "zsh.h",
          "line": 334
        }
      },
      "AMPOUTANG": {
        "token": "AMPOUTANG",
        "matches": "&>",
        "source": {
          "file": "zsh.h",
          "line": 335
        }
      },
      "OUTANGAMPBANG": {
        "token": "OUTANGAMPBANG",
        "matches": "&>|",
        "source": {
          "file": "zsh.h",
          "line": 336
        }
      },
      "DOUTANGAMP": {
        "token": "DOUTANGAMP",
        "matches": ">>&",
        "source": {
          "file": "zsh.h",
          "line": 337
        }
      },
      "DOUTANGAMPBANG": {
        "token": "DOUTANGAMPBANG",
        "matches": ">>&|",
        "source": {
          "file": "zsh.h",
          "line": 338
        }
      },
      "TRINANG": {
        "token": "TRINANG",
        "matches": "<<<",
        "source": {
          "file": "zsh.h",
          "line": 339
        }
      },
      "BAR": {
        "token": "BAR",
        "matches": "|",
        "source": {
          "file": "zsh.h",
          "line": 340
        }
      },
      "BARAMP": {
        "token": "BARAMP",
        "matches": "|&",
        "source": {
          "file": "zsh.h",
          "line": 341
        }
      },
      "INOUTPAR": {
        "token": "INOUTPAR",
        "matches": "()",
        "source": {
          "file": "zsh.h",
          "line": 342
        }
      },
      "DINPAR": {
        "token": "DINPAR",
        "matches": "((",
        "source": {
          "file": "zsh.h",
          "line": 343
        }
      },
      "DOUTPAR": {
        "token": "DOUTPAR",
        "matches": "))",
        "source": {
          "file": "zsh.h",
          "line": 344
        }
      },
      "AMPERBANG": {
        "token": "AMPERBANG",
        "matches": "&|",
        "source": {
          "file": "zsh.h",
          "line": 345
        }
      },
      "SEMIAMP": {
        "token": "SEMIAMP",
        "matches": ";&",
        "source": {
          "file": "zsh.h",
          "line": 346
        }
      },
      "SEMIBAR": {
        "token": "SEMIBAR",
        "matches": ";|",
        "source": {
          "file": "zsh.h",
          "line": 347
        }
      },
      "BANG": {
        "token": "BANG",
        "matches": "!",
        "source": {
          "file": "zsh.h",
          "line": 356
        }
      },
      "DINBRACK": {
        "token": "DINBRACK",
        "matches": "[[",
        "source": {
          "file": "zsh.h",
          "line": 357
        }
      },
      "INBRACE": {
        "token": "INBRACE",
        "matches": "{",
        "source": {
          "file": "zsh.h",
          "line": 358
        }
      },
      "OUTBRACE": {
        "token": "OUTBRACE",
        "matches": "}",
        "source": {
          "file": "zsh.h",
          "line": 359
        }
      },
      "CASE": {
        "token": "CASE",
        "matches": "case",
        "source": {
          "file": "zsh.h",
          "line": 360
        }
      },
      "COPROC": {
        "token": "COPROC",
        "matches": "coproc",
        "source": {
          "file": "zsh.h",
          "line": 361
        }
      },
      "DOLOOP": {
        "token": "DOLOOP",
        "matches": "do",
        "source": {
          "file": "zsh.h",
          "line": 362
        }
      },
      "DONE": {
        "token": "DONE",
        "matches": "done",
        "source": {
          "file": "zsh.h",
          "line": 363
        }
      },
      "ELIF": {
        "token": "ELIF",
        "matches": "elif",
        "source": {
          "file": "zsh.h",
          "line": 364
        }
      },
      "ELSE": {
        "token": "ELSE",
        "matches": "else",
        "source": {
          "file": "zsh.h",
          "line": 365
        }
      },
      "ZEND": {
        "token": "ZEND",
        "matches": "end",
        "source": {
          "file": "zsh.h",
          "line": 366
        }
      },
      "ESAC": {
        "token": "ESAC",
        "matches": "esac",
        "source": {
          "file": "zsh.h",
          "line": 367
        }
      },
      "FI": {
        "token": "FI",
        "matches": "fi",
        "source": {
          "file": "zsh.h",
          "line": 368
        }
      },
      "FOR": {
        "token": "FOR",
        "matches": "for",
        "source": {
          "file": "zsh.h",
          "line": 369
        }
      },
      "FOREACH": {
        "token": "FOREACH",
        "matches": "foreach",
        "source": {
          "file": "zsh.h",
          "line": 370
        }
      },
      "FUNC": {
        "token": "FUNC",
        "matches": "function",
        "source": {
          "file": "zsh.h",
          "line": 371
        }
      },
      "IF": {
        "token": "IF",
        "matches": "if",
        "source": {
          "file": "zsh.h",
          "line": 372
        }
      },
      "NOCORRECT": {
        "token": "NOCORRECT",
        "matches": "nocorrect",
        "source": {
          "file": "zsh.h",
          "line": 373
        }
      },
      "REPEAT": {
        "token": "REPEAT",
        "matches": "repeat",
        "source": {
          "file": "zsh.h",
          "line": 374
        }
      },
      "SELECT": {
        "token": "SELECT",
        "matches": "select",
        "source": {
          "file": "zsh.h",
          "line": 375
        }
      },
      "THEN": {
        "token": "THEN",
        "matches": "then",
        "source": {
          "file": "zsh.h",
          "line": 376
        }
      },
      "TIME": {
        "token": "TIME",
        "matches": "time",
        "source": {
          "file": "zsh.h",
          "line": 377
        }
      },
      "UNTIL": {
        "token": "UNTIL",
        "matches": "until",
        "source": {
          "file": "zsh.h",
          "line": 378
        }
      },
      "WHILE": {
        "token": "WHILE",
        "matches": "while",
        "source": {
          "file": "zsh.h",
          "line": 379
        }
      },
      "TYPESET": {
        "token": "TYPESET",
        "matches": [
          "declare",
          "export",
          "float",
          "integer",
          "local",
          "readonly",
          "typeset"
        ],
        "source": {
          "file": "zsh.h",
          "line": 380
        }
      },
      "parameter": {
        "union": [
          {
            "$ref": "variable"
          },
          {
            "pattern": "*"
          },
          {
            "pattern": "@"
          },
          {
            "pattern": "#"
          },
          {
            "pattern": "?"
          },
          {
            "pattern": "-"
          },
          {
            "pattern": "$"
          },
          {
            "pattern": "!"
          }
        ]
      },
      "variable": {
        "pattern": "[a-zA-Z0-9_]+"
      },
      "string": {
        "$ref": "list",
        "source": {
          "file": "exec.c",
          "line": 243,
          "function": "parse_string"
        }
      },
      "subscript": {
        "pattern": "[subscript]",
        "source": {
          "file": "lex.c",
          "line": 1675,
          "function": "parse_subscript"
        }
      },
      "subst_string": {
        "pattern": "[subst_string]",
        "source": {
          "file": "lex.c",
          "line": 1728,
          "function": "parse_subst_string"
        }
      },
      "context_save": {
        "union": [
          {
            "pattern": "[context_save]",
            "source": {
              "file": "parse.syms",
              "line": 18,
              "function": "parse_context_save"
            }
          },
          {
            "variant": {
              "pattern": "[context_save]",
              "source": {
                "file": "parse.syms",
                "line": 18,
                "function": "parse_context_save"
              }
            },
            "condition": {
              "lexstate": "ALIASSPACEFLAG"
            },
            "description": "context_save sets lexer state ALIASSPACEFLAG",
            "source": {
              "file": "parse.c",
              "line": 300,
              "function": "parse_context_save",
              "context": "sets ALIASSPACEFLAG"
            }
          },
          {
            "variant": {
              "pattern": "[context_save]",
              "source": {
                "file": "parse.syms",
                "line": 18,
                "function": "parse_context_save"
              }
            },
            "condition": {
              "lexstate": "INCASEPAT"
            },
            "description": "context_save sets lexer state INCASEPAT",
            "source": {
              "file": "parse.c",
              "line": 303,
              "function": "parse_context_save",
              "context": "sets INCASEPAT"
            }
          },
          {
            "variant": {
              "pattern": "[context_save]",
              "source": {
                "file": "parse.syms",
                "line": 18,
                "function": "parse_context_save"
              }
            },
            "condition": {
              "lexstate": "INCMDPOS"
            },
            "description": "context_save sets lexer state INCMDPOS",
            "source": {
              "file": "parse.c",
              "line": 299,
              "function": "parse_context_save",
              "context": "sets INCMDPOS"
            }
          },
          {
            "variant": {
              "pattern": "[context_save]",
              "source": {
                "file": "parse.syms",
                "line": 18,
                "function": "parse_context_save"
              }
            },
            "condition": {
              "lexstate": "INCOND"
            },
            "description": "context_save sets lexer state INCOND",
            "source": {
              "file": "parse.c",
              "line": 301,
              "function": "parse_context_save",
              "context": "sets INCOND"
            }
          },
          {
            "variant": {
              "pattern": "[context_save]",
              "source": {
                "file": "parse.syms",
                "line": 18,
                "function": "parse_context_save"
              }
            },
            "condition": {
              "lexstate": "INFOR"
            },
            "description": "context_save sets lexer state INFOR",
            "source": {
              "file": "parse.c",
              "line": 305,
              "function": "parse_context_save",
              "context": "sets INFOR"
            }
          },
          {
            "variant": {
              "pattern": "[context_save]",
              "source": {
                "file": "parse.syms",
                "line": 18,
                "function": "parse_context_save"
              }
            },
            "condition": {
              "lexstate": "INREDIR"
            },
            "description": "context_save sets lexer state INREDIR",
            "source": {
              "file": "parse.c",
              "line": 302,
              "function": "parse_context_save",
              "context": "sets INREDIR"
            }
          },
          {
            "variant": {
              "pattern": "[context_save]",
              "source": {
                "file": "parse.syms",
                "line": 18,
                "function": "parse_context_save"
              }
            },
            "condition": {
              "lexstate": "INTYPESET"
            },
            "description": "context_save sets lexer state INTYPESET",
            "source": {
              "file": "parse.c",
              "line": 307,
              "function": "parse_context_save",
              "context": "sets INTYPESET"
            }
          },
          {
            "variant": {
              "pattern": "[context_save]",
              "source": {
                "file": "parse.syms",
                "line": 18,
                "function": "parse_context_save"
              }
            },
            "condition": {
              "lexstate": "ISNEWLIN"
            },
            "description": "context_save sets lexer state ISNEWLIN",
            "source": {
              "file": "parse.c",
              "line": 304,
              "function": "parse_context_save",
              "context": "sets ISNEWLIN"
            }
          }
        ],
        "description": "context_save (modifies lexer states: INCMDPOS, ALIASSPACEFLAG, INCOND, INREDIR, INCASEPAT, ISNEWLIN, INFOR, INTYPESET)",
        "source": {
          "file": "parse.syms",
          "line": 18,
          "function": "parse_context_save"
        }
      },
      "context_restore": {
        "union": [
          {
            "pattern": "[context_restore]",
            "source": {
              "file": "parse.syms",
              "line": 19,
              "function": "parse_context_restore"
            }
          },
          {
            "variant": {
              "pattern": "[context_restore]",
              "source": {
                "file": "parse.syms",
                "line": 19,
                "function": "parse_context_restore"
              }
            },
            "condition": {
              "lexstate": "ALIASSPACEFLAG"
            },
            "description": "context_restore sets lexer state ALIASSPACEFLAG",
            "source": {
              "file": "parse.c",
              "line": 334,
              "function": "parse_context_restore",
              "context": "sets ALIASSPACEFLAG"
            }
          },
          {
            "variant": {
              "pattern": "[context_restore]",
              "source": {
                "file": "parse.syms",
                "line": 19,
                "function": "parse_context_restore"
              }
            },
            "condition": {
              "lexstate": "INCASEPAT"
            },
            "description": "context_restore sets lexer state INCASEPAT",
            "source": {
              "file": "parse.c",
              "line": 337,
              "function": "parse_context_restore",
              "context": "sets INCASEPAT"
            }
          },
          {
            "variant": {
              "pattern": "[context_restore]",
              "source": {
                "file": "parse.syms",
                "line": 19,
                "function": "parse_context_restore"
              }
            },
            "condition": {
              "lexstate": "INCMDPOS"
            },
            "description": "context_restore sets lexer state INCMDPOS",
            "source": {
              "file": "parse.c",
              "line": 333,
              "function": "parse_context_restore",
              "context": "sets INCMDPOS"
            }
          },
          {
            "variant": {
              "pattern": "[context_restore]",
              "source": {
                "file": "parse.syms",
                "line": 19,
                "function": "parse_context_restore"
              }
            },
            "condition": {
              "lexstate": "INCOND"
            },
            "description": "context_restore sets lexer state INCOND",
            "source": {
              "file": "parse.c",
              "line": 335,
              "function": "parse_context_restore",
              "context": "sets INCOND"
            }
          },
          {
            "variant": {
              "pattern": "[context_restore]",
              "source": {
                "file": "parse.syms",
                "line": 19,
                "function": "parse_context_restore"
              }
            },
            "condition": {
              "lexstate": "INFOR"
            },
            "description": "context_restore sets lexer state INFOR",
            "source": {
              "file": "parse.c",
              "line": 339,
              "function": "parse_context_restore",
              "context": "sets INFOR"
            }
          },
          {
            "variant": {
              "pattern": "[context_restore]",
              "source": {
                "file": "parse.syms",
                "line": 19,
                "function": "parse_context_restore"
              }
            },
            "condition": {
              "lexstate": "INREDIR"
            },
            "description": "context_restore sets lexer state INREDIR",
            "source": {
              "file": "parse.c",
              "line": 336,
              "function": "parse_context_restore",
              "context": "sets INREDIR"
            }
          },
          {
            "variant": {
              "pattern": "[context_restore]",
              "source": {
                "file": "parse.syms",
                "line": 19,
                "function": "parse_context_restore"
              }
            },
            "condition": {
              "lexstate": "INTYPESET"
            },
            "description": "context_restore sets lexer state INTYPESET",
            "source": {
              "file": "parse.c",
              "line": 341,
              "function": "parse_context_restore",
              "context": "sets INTYPESET"
            }
          },
          {
            "variant": {
              "pattern": "[context_restore]",
              "source": {
                "file": "parse.syms",
                "line": 19,
                "function": "parse_context_restore"
              }
            },
            "condition": {
              "lexstate": "ISNEWLIN"
            },
            "description": "context_restore sets lexer state ISNEWLIN",
            "source": {
              "file": "parse.c",
              "line": 338,
              "function": "parse_context_restore",
              "context": "sets ISNEWLIN"
            }
          }
        ],
        "description": "context_restore (modifies lexer states: INCMDPOS, ALIASSPACEFLAG, INCOND, INREDIR, INCASEPAT, ISNEWLIN, INFOR, INTYPESET)",
        "source": {
          "file": "parse.syms",
          "line": 19,
          "function": "parse_context_restore"
        }
      },
      "event": {
        "union": [
          {
            "union": [
              {
                "optional": {
                  "$ref": "sublist",
                  "source": {
                    "file": "parse.syms",
                    "line": 26,
                    "function": "par_event"
                  }
                },
                "description": "par_event contains if statement without else with parser function calls",
                "source": {
                  "file": "parse.syms",
                  "line": 26,
                  "function": "par_event"
                }
              },
              {
                "variant": {
                  "optional": {
                    "$ref": "sublist",
                    "source": {
                      "file": "parse.syms",
                      "line": 26,
                      "function": "par_event"
                    }
                  },
                  "description": "par_event contains if statement without else with parser function calls",
                  "source": {
                    "file": "parse.syms",
                    "line": 26,
                    "function": "par_event"
                  }
                },
                "condition": {
                  "lexstate": "ALIASSPACEFLAG"
                },
                "description": "event sets lexer state ALIASSPACEFLAG",
                "source": {
                  "file": "parse.c",
                  "line": 614,
                  "function": "parse_event",
                  "context": "sets ALIASSPACEFLAG"
                }
              },
              {
                "variant": {
                  "optional": {
                    "$ref": "sublist",
                    "source": {
                      "file": "parse.syms",
                      "line": 26,
                      "function": "par_event"
                    }
                  },
                  "description": "par_event contains if statement without else with parser function calls",
                  "source": {
                    "file": "parse.syms",
                    "line": 26,
                    "function": "par_event"
                  }
                },
                "condition": {
                  "lexstate": "INCMDPOS"
                },
                "description": "event sets lexer state INCMDPOS",
                "source": {
                  "file": "parse.c",
                  "line": 613,
                  "function": "parse_event",
                  "context": "sets INCMDPOS"
                }
              }
            ],
            "description": "event (modifies lexer states: INCMDPOS, ALIASSPACEFLAG)",
            "source": {
              "file": "parse.syms",
              "line": 26,
              "function": "par_event"
            }
          },
          {
            "variant": {
              "union": [
                {
                  "optional": {
                    "$ref": "sublist",
                    "source": {
                      "file": "parse.syms",
                      "line": 26,
                      "function": "par_event"
                    }
                  },
                  "description": "par_event contains if statement without else with parser function calls",
                  "source": {
                    "file": "parse.syms",
                    "line": 26,
                    "function": "par_event"
                  }
                },
                {
                  "variant": {
                    "optional": {
                      "$ref": "sublist",
                      "source": {
                        "file": "parse.syms",
                        "line": 26,
                        "function": "par_event"
                      }
                    },
                    "description": "par_event contains if statement without else with parser function calls",
                    "source": {
                      "file": "parse.syms",
                      "line": 26,
                      "function": "par_event"
                    }
                  },
                  "condition": {
                    "lexstate": "ALIASSPACEFLAG"
                  },
                  "description": "event sets lexer state ALIASSPACEFLAG",
                  "source": {
                    "file": "parse.c",
                    "line": 614,
                    "function": "parse_event",
                    "context": "sets ALIASSPACEFLAG"
                  }
                },
                {
                  "variant": {
                    "optional": {
                      "$ref": "sublist",
                      "source": {
                        "file": "parse.syms",
                        "line": 26,
                        "function": "par_event"
                      }
                    },
                    "description": "par_event contains if statement without else with parser function calls",
                    "source": {
                      "file": "parse.syms",
                      "line": 26,
                      "function": "par_event"
                    }
                  },
                  "condition": {
                    "lexstate": "INCMDPOS"
                  },
                  "description": "event sets lexer state INCMDPOS",
                  "source": {
                    "file": "parse.c",
                    "line": 613,
                    "function": "parse_event",
                    "context": "sets INCMDPOS"
                  }
                }
              ],
              "description": "event (modifies lexer states: INCMDPOS, ALIASSPACEFLAG)",
              "source": {
                "file": "parse.syms",
                "line": 26,
                "function": "par_event"
              }
            },
            "condition": {
              "lexstate": "ISNEWLIN"
            },
            "description": "event sets lexer state ISNEWLIN",
            "source": {
              "file": "parse.c",
              "line": 636,
              "function": "par_event",
              "context": "sets ISNEWLIN"
            }
          }
        ],
        "description": "event (modifies lexer states: ISNEWLIN)",
        "source": {
          "file": "parse.syms",
          "line": 26,
          "function": "par_event"
        }
      },
      "list": {
        "union": [
          {
            "$ref": "sublist",
            "source": {
              "file": "parse.syms",
              "line": 33,
              "function": "par_list"
            }
          },
          {
            "variant": {
              "$ref": "sublist",
              "source": {
                "file": "parse.syms",
                "line": 33,
                "function": "par_list"
              }
            },
            "condition": {
              "lexstate": "INCMDPOS"
            },
            "description": "list sets lexer state INCMDPOS",
            "source": {
              "file": "parse.c",
              "line": 787,
              "function": "par_list",
              "context": "sets INCMDPOS"
            }
          }
        ],
        "description": "list (modifies lexer states: INCMDPOS)",
        "source": {
          "file": "parse.syms",
          "line": 33,
          "function": "par_list"
        }
      },
      "cond": {
        "optional": {
          "$ref": "cond_1",
          "source": {
            "file": "parse.syms",
            "line": 54,
            "function": "par_cond"
          }
        },
        "description": "par_cond contains if statement without else with parser function calls",
        "source": {
          "file": "parse.syms",
          "line": 54,
          "function": "par_cond"
        }
      },
      "list1": {
        "$ref": "sublist",
        "source": {
          "file": "parse.syms",
          "line": 34,
          "function": "par_list1"
        }
      },
      "sublist": {
        "$ref": "sublist2",
        "source": {
          "file": "parse.syms",
          "line": 35,
          "function": "par_sublist"
        }
      },
      "sublist2": {
        "optional": {
          "$ref": "pline",
          "source": {
            "file": "parse.syms",
            "line": 36,
            "function": "par_sublist2"
          }
        },
        "description": "par_sublist2 contains if statement without else with parser function calls",
        "source": {
          "file": "parse.syms",
          "line": 36,
          "function": "par_sublist2"
        }
      },
      "pline": {
        "optional": {
          "$ref": "cmd",
          "source": {
            "file": "parse.syms",
            "line": 37,
            "function": "par_pline"
          }
        },
        "description": "par_pline contains if statement without else with parser function calls",
        "source": {
          "file": "parse.syms",
          "line": 37,
          "function": "par_pline"
        }
      },
      "cmd": {
        "union": [
          {
            "optional": {
              "union": [
                {
                  "$ref": "case"
                },
                {
                  "$ref": "dinbrack"
                },
                {
                  "$ref": "for"
                },
                {
                  "$ref": "funcdef"
                },
                {
                  "$ref": "if"
                },
                {
                  "$ref": "repeat"
                },
                {
                  "$ref": "simple"
                },
                {
                  "$ref": "subsh"
                },
                {
                  "$ref": "time"
                },
                {
                  "$ref": "while"
                }
              ],
              "source": {
                "file": "parse.syms",
                "line": 38,
                "function": "par_cmd"
              }
            },
            "description": "par_cmd contains if statement without else with parser function calls",
            "source": {
              "file": "parse.syms",
              "line": 38,
              "function": "par_cmd"
            }
          },
          {
            "variant": {
              "optional": {
                "union": [
                  {
                    "$ref": "case"
                  },
                  {
                    "$ref": "dinbrack"
                  },
                  {
                    "$ref": "for"
                  },
                  {
                    "$ref": "funcdef"
                  },
                  {
                    "$ref": "if"
                  },
                  {
                    "$ref": "repeat"
                  },
                  {
                    "$ref": "simple"
                  },
                  {
                    "$ref": "subsh"
                  },
                  {
                    "$ref": "time"
                  },
                  {
                    "$ref": "while"
                  }
                ],
                "source": {
                  "file": "parse.syms",
                  "line": 38,
                  "function": "par_cmd"
                }
              },
              "description": "par_cmd contains if statement without else with parser function calls",
              "source": {
                "file": "parse.syms",
                "line": 38,
                "function": "par_cmd"
              }
            },
            "condition": {
              "lexstate": "INCASEPAT"
            },
            "description": "cmd sets lexer state INCASEPAT",
            "source": {
              "file": "parse.c",
              "line": 1069,
              "function": "par_cmd",
              "context": "sets INCASEPAT"
            }
          },
          {
            "variant": {
              "optional": {
                "union": [
                  {
                    "$ref": "case"
                  },
                  {
                    "$ref": "dinbrack"
                  },
                  {
                    "$ref": "for"
                  },
                  {
                    "$ref": "funcdef"
                  },
                  {
                    "$ref": "if"
                  },
                  {
                    "$ref": "repeat"
                  },
                  {
                    "$ref": "simple"
                  },
                  {
                    "$ref": "subsh"
                  },
                  {
                    "$ref": "time"
                  },
                  {
                    "$ref": "while"
                  }
                ],
                "source": {
                  "file": "parse.syms",
                  "line": 38,
                  "function": "par_cmd"
                }
              },
              "description": "par_cmd contains if statement without else with parser function calls",
              "source": {
                "file": "parse.syms",
                "line": 38,
                "function": "par_cmd"
              }
            },
            "condition": {
              "lexstate": "INCMDPOS"
            },
            "description": "cmd sets lexer state INCMDPOS",
            "source": {
              "file": "parse.c",
              "line": 1068,
              "function": "par_cmd",
              "context": "sets INCMDPOS"
            }
          },
          {
            "variant": {
              "optional": {
                "union": [
                  {
                    "$ref": "case"
                  },
                  {
                    "$ref": "dinbrack"
                  },
                  {
                    "$ref": "for"
                  },
                  {
                    "$ref": "funcdef"
                  },
                  {
                    "$ref": "if"
                  },
                  {
                    "$ref": "repeat"
                  },
                  {
                    "$ref": "simple"
                  },
                  {
                    "$ref": "subsh"
                  },
                  {
                    "$ref": "time"
                  },
                  {
                    "$ref": "while"
                  }
                ],
                "source": {
                  "file": "parse.syms",
                  "line": 38,
                  "function": "par_cmd"
                }
              },
              "description": "par_cmd contains if statement without else with parser function calls",
              "source": {
                "file": "parse.syms",
                "line": 38,
                "function": "par_cmd"
              }
            },
            "condition": {
              "lexstate": "INCOND"
            },
            "description": "cmd sets lexer state INCOND",
            "source": {
              "file": "parse.c",
              "line": 1070,
              "function": "par_cmd",
              "context": "sets INCOND"
            }
          },
          {
            "variant": {
              "optional": {
                "union": [
                  {
                    "$ref": "case"
                  },
                  {
                    "$ref": "dinbrack"
                  },
                  {
                    "$ref": "for"
                  },
                  {
                    "$ref": "funcdef"
                  },
                  {
                    "$ref": "if"
                  },
                  {
                    "$ref": "repeat"
                  },
                  {
                    "$ref": "simple"
                  },
                  {
                    "$ref": "subsh"
                  },
                  {
                    "$ref": "time"
                  },
                  {
                    "$ref": "while"
                  }
                ],
                "source": {
                  "file": "parse.syms",
                  "line": 38,
                  "function": "par_cmd"
                }
              },
              "description": "par_cmd contains if statement without else with parser function calls",
              "source": {
                "file": "parse.syms",
                "line": 38,
                "function": "par_cmd"
              }
            },
            "condition": {
              "lexstate": "INTYPESET"
            },
            "description": "cmd sets lexer state INTYPESET",
            "source": {
              "file": "parse.c",
              "line": 1071,
              "function": "par_cmd",
              "context": "sets INTYPESET"
            }
          }
        ],
        "description": "cmd (modifies lexer states: INCMDPOS, INCASEPAT, INCOND, INTYPESET)",
        "source": {
          "file": "parse.syms",
          "line": 38,
          "function": "par_cmd"
        }
      },
      "for": {
        "union": [
          {
            "union": [
              {
                "$ref": "list"
              },
              {
                "$ref": "list1"
              },
              {
                "$ref": "nl_wordlist"
              },
              {
                "$ref": "wordlist"
              }
            ],
            "source": {
              "file": "parse.syms",
              "line": 39,
              "function": "par_for"
            }
          },
          {
            "variant": {
              "union": [
                {
                  "$ref": "list"
                },
                {
                  "$ref": "list1"
                },
                {
                  "$ref": "nl_wordlist"
                },
                {
                  "$ref": "wordlist"
                }
              ],
              "source": {
                "file": "parse.syms",
                "line": 39,
                "function": "par_for"
              }
            },
            "condition": {
              "lexstate": "INCASEPAT"
            },
            "description": "for sets lexer state INCASEPAT",
            "source": {
              "file": "parse.c",
              "line": 1168,
              "function": "par_for",
              "context": "sets INCASEPAT"
            }
          },
          {
            "variant": {
              "union": [
                {
                  "$ref": "list"
                },
                {
                  "$ref": "list1"
                },
                {
                  "$ref": "nl_wordlist"
                },
                {
                  "$ref": "wordlist"
                }
              ],
              "source": {
                "file": "parse.syms",
                "line": 39,
                "function": "par_for"
              }
            },
            "condition": {
              "lexstate": "INCMDPOS"
            },
            "description": "for sets lexer state INCMDPOS",
            "source": {
              "file": "parse.c",
              "line": 1090,
              "function": "par_for",
              "context": "sets INCMDPOS"
            }
          },
          {
            "variant": {
              "union": [
                {
                  "$ref": "list"
                },
                {
                  "$ref": "list1"
                },
                {
                  "$ref": "nl_wordlist"
                },
                {
                  "$ref": "wordlist"
                }
              ],
              "source": {
                "file": "parse.syms",
                "line": 39,
                "function": "par_for"
              }
            },
            "condition": {
              "lexstate": "INFOR"
            },
            "description": "for sets lexer state INFOR",
            "source": {
              "file": "parse.c",
              "line": 1091,
              "function": "par_for",
              "context": "sets INFOR"
            }
          },
          {
            "variant": {
              "union": [
                {
                  "$ref": "list"
                },
                {
                  "$ref": "list1"
                },
                {
                  "$ref": "nl_wordlist"
                },
                {
                  "$ref": "wordlist"
                }
              ],
              "source": {
                "file": "parse.syms",
                "line": 39,
                "function": "par_for"
              }
            },
            "condition": {
              "lexstate": "ISNEWLIN"
            },
            "description": "for sets lexer state ISNEWLIN",
            "source": {
              "file": "parse.c",
              "line": 1137,
              "function": "par_for",
              "context": "sets ISNEWLIN"
            }
          }
        ],
        "description": "for (modifies lexer states: INCMDPOS, INFOR, ISNEWLIN, INCASEPAT)",
        "source": {
          "file": "parse.syms",
          "line": 39,
          "function": "par_for"
        }
      },
      "case": {
        "union": [
          {
            "repeat": {
              "$ref": "list",
              "source": {
                "file": "parse.syms",
                "line": 40,
                "function": "par_case"
              }
            },
            "min": 0,
            "description": "par_case contains for loop with parser function calls",
            "source": {
              "file": "parse.syms",
              "line": 40,
              "function": "par_case"
            }
          },
          {
            "variant": {
              "repeat": {
                "$ref": "list",
                "source": {
                  "file": "parse.syms",
                  "line": 40,
                  "function": "par_case"
                }
              },
              "min": 0,
              "description": "par_case contains for loop with parser function calls",
              "source": {
                "file": "parse.syms",
                "line": 40,
                "function": "par_case"
              }
            },
            "condition": {
              "lexstate": "INCASEPAT"
            },
            "description": "case sets lexer state INCASEPAT",
            "source": {
              "file": "parse.c",
              "line": 1232,
              "function": "par_case",
              "context": "sets INCASEPAT"
            }
          },
          {
            "variant": {
              "repeat": {
                "$ref": "list",
                "source": {
                  "file": "parse.syms",
                  "line": 40,
                  "function": "par_case"
                }
              },
              "min": 0,
              "description": "par_case contains for loop with parser function calls",
              "source": {
                "file": "parse.syms",
                "line": 40,
                "function": "par_case"
              }
            },
            "condition": {
              "lexstate": "INCMDPOS"
            },
            "description": "case sets lexer state INCMDPOS",
            "source": {
              "file": "parse.c",
              "line": 1212,
              "function": "par_case",
              "context": "sets INCMDPOS"
            }
          }
        ],
        "description": "case (modifies lexer states: INCMDPOS, INCASEPAT)",
        "source": {
          "file": "parse.syms",
          "line": 40,
          "function": "par_case"
        }
      },
      "if": {
        "union": [
          {
            "repeat": {
              "union": [
                {
                  "$ref": "list"
                },
                {
                  "$ref": "list1"
                }
              ],
              "source": {
                "file": "parse.syms",
                "line": 41,
                "function": "par_if"
              }
            },
            "min": 0,
            "description": "par_if contains for loop with parser function calls",
            "source": {
              "file": "parse.syms",
              "line": 41,
              "function": "par_if"
            }
          },
          {
            "variant": {
              "repeat": {
                "union": [
                  {
                    "$ref": "list"
                  },
                  {
                    "$ref": "list1"
                  }
                ],
                "source": {
                  "file": "parse.syms",
                  "line": 41,
                  "function": "par_if"
                }
              },
              "min": 0,
              "description": "par_if contains for loop with parser function calls",
              "source": {
                "file": "parse.syms",
                "line": 41,
                "function": "par_if"
              }
            },
            "condition": {
              "lexstate": "INCASEPAT"
            },
            "description": "if sets lexer state INCASEPAT",
            "source": {
              "file": "parse.c",
              "line": 1434,
              "function": "par_if",
              "context": "sets INCASEPAT"
            }
          },
          {
            "variant": {
              "repeat": {
                "union": [
                  {
                    "$ref": "list"
                  },
                  {
                    "$ref": "list1"
                  }
                ],
                "source": {
                  "file": "parse.syms",
                  "line": 41,
                  "function": "par_if"
                }
              },
              "min": 0,
              "description": "par_if contains for loop with parser function calls",
              "source": {
                "file": "parse.syms",
                "line": 41,
                "function": "par_if"
              }
            },
            "condition": {
              "lexstate": "INCMDPOS"
            },
            "description": "if sets lexer state INCMDPOS",
            "source": {
              "file": "parse.c",
              "line": 1419,
              "function": "par_if",
              "context": "sets INCMDPOS"
            }
          }
        ],
        "description": "if (modifies lexer states: INCMDPOS, INCASEPAT)",
        "source": {
          "file": "parse.syms",
          "line": 41,
          "function": "par_if"
        }
      },
      "while": {
        "union": [
          {
            "union": [
              {
                "$ref": "list"
              },
              {
                "$ref": "list1"
              }
            ],
            "source": {
              "file": "parse.syms",
              "line": 42,
              "function": "par_while"
            }
          },
          {
            "variant": {
              "union": [
                {
                  "$ref": "list"
                },
                {
                  "$ref": "list1"
                }
              ],
              "source": {
                "file": "parse.syms",
                "line": 42,
                "function": "par_while"
              }
            },
            "condition": {
              "lexstate": "INCASEPAT"
            },
            "description": "while sets lexer state INCASEPAT",
            "source": {
              "file": "parse.c",
              "line": 1524,
              "function": "par_while",
              "context": "sets INCASEPAT"
            }
          },
          {
            "variant": {
              "union": [
                {
                  "$ref": "list"
                },
                {
                  "$ref": "list1"
                }
              ],
              "source": {
                "file": "parse.syms",
                "line": 42,
                "function": "par_while"
              }
            },
            "condition": {
              "lexstate": "INCMDPOS"
            },
            "description": "while sets lexer state INCMDPOS",
            "source": {
              "file": "parse.c",
              "line": 1525,
              "function": "par_while",
              "context": "sets INCMDPOS"
            }
          }
        ],
        "description": "while (modifies lexer states: INCASEPAT, INCMDPOS)",
        "source": {
          "file": "parse.syms",
          "line": 42,
          "function": "par_while"
        }
      },
      "repeat": {
        "union": [
          {
            "union": [
              {
                "$ref": "list"
              },
              {
                "$ref": "list1"
              }
            ],
            "source": {
              "file": "parse.syms",
              "line": 43,
              "function": "par_repeat"
            }
          },
          {
            "variant": {
              "union": [
                {
                  "$ref": "list"
                },
                {
                  "$ref": "list1"
                }
              ],
              "source": {
                "file": "parse.syms",
                "line": 43,
                "function": "par_repeat"
              }
            },
            "condition": {
              "lexstate": "INCASEPAT"
            },
            "description": "repeat sets lexer state INCASEPAT",
            "source": {
              "file": "parse.c",
              "line": 1579,
              "function": "par_repeat",
              "context": "sets INCASEPAT"
            }
          },
          {
            "variant": {
              "union": [
                {
                  "$ref": "list"
                },
                {
                  "$ref": "list1"
                }
              ],
              "source": {
                "file": "parse.syms",
                "line": 43,
                "function": "par_repeat"
              }
            },
            "condition": {
              "lexstate": "INCMDPOS"
            },
            "description": "repeat sets lexer state INCMDPOS",
            "source": {
              "file": "parse.c",
              "line": 1568,
              "function": "par_repeat",
              "context": "sets INCMDPOS"
            }
          }
        ],
        "description": "repeat (modifies lexer states: INCMDPOS, INCASEPAT)",
        "source": {
          "file": "parse.syms",
          "line": 43,
          "function": "par_repeat"
        }
      },
      "subsh": {
        "union": [
          {
            "$ref": "list",
            "source": {
              "file": "parse.syms",
              "line": 44,
              "function": "par_subsh"
            }
          },
          {
            "variant": {
              "$ref": "list",
              "source": {
                "file": "parse.syms",
                "line": 44,
                "function": "par_subsh"
              }
            },
            "condition": {
              "lexstate": "INCASEPAT"
            },
            "description": "subsh sets lexer state INCASEPAT",
            "source": {
              "file": "parse.c",
              "line": 1645,
              "function": "par_subsh",
              "context": "sets INCASEPAT"
            }
          },
          {
            "variant": {
              "$ref": "list",
              "source": {
                "file": "parse.syms",
                "line": 44,
                "function": "par_subsh"
              }
            },
            "condition": {
              "lexstate": "INCMDPOS"
            },
            "description": "subsh sets lexer state INCMDPOS",
            "source": {
              "file": "parse.c",
              "line": 1627,
              "function": "par_subsh",
              "context": "sets INCMDPOS"
            }
          }
        ],
        "description": "subsh (modifies lexer states: INCMDPOS, INCASEPAT)",
        "source": {
          "file": "parse.syms",
          "line": 44,
          "function": "par_subsh"
        }
      },
      "funcdef": {
        "union": [
          {
            "union": [
              {
                "$ref": "list"
              },
              {
                "$ref": "list1"
              }
            ],
            "source": {
              "file": "parse.syms",
              "line": 45,
              "function": "par_funcdef"
            }
          },
          {
            "variant": {
              "union": [
                {
                  "$ref": "list"
                },
                {
                  "$ref": "list1"
                }
              ],
              "source": {
                "file": "parse.syms",
                "line": 45,
                "function": "par_funcdef"
              }
            },
            "condition": {
              "lexstate": "INCMDPOS"
            },
            "description": "funcdef sets lexer state INCMDPOS",
            "source": {
              "file": "parse.c",
              "line": 1677,
              "function": "par_funcdef",
              "context": "sets INCMDPOS"
            }
          }
        ],
        "description": "funcdef (modifies lexer states: INCMDPOS)",
        "source": {
          "file": "parse.syms",
          "line": 45,
          "function": "par_funcdef"
        }
      },
      "time": {
        "$ref": "sublist2",
        "source": {
          "file": "parse.syms",
          "line": 46,
          "function": "par_time"
        }
      },
      "dinbrack": {
        "union": [
          {
            "$ref": "cond",
            "source": {
              "file": "parse.syms",
              "line": 47,
              "function": "par_dinbrack"
            }
          },
          {
            "variant": {
              "$ref": "cond",
              "source": {
                "file": "parse.syms",
                "line": 47,
                "function": "par_dinbrack"
              }
            },
            "condition": {
              "lexstate": "INCMDPOS"
            },
            "description": "dinbrack sets lexer state INCMDPOS",
            "source": {
              "file": "parse.c",
              "line": 1811,
              "function": "par_dinbrack",
              "context": "sets INCMDPOS"
            }
          },
          {
            "variant": {
              "$ref": "cond",
              "source": {
                "file": "parse.syms",
                "line": 47,
                "function": "par_dinbrack"
              }
            },
            "condition": {
              "lexstate": "INCOND"
            },
            "description": "dinbrack sets lexer state INCOND",
            "source": {
              "file": "parse.c",
              "line": 1810,
              "function": "par_dinbrack",
              "context": "sets INCOND"
            }
          }
        ],
        "description": "dinbrack (modifies lexer states: INCOND, INCMDPOS)",
        "source": {
          "file": "parse.syms",
          "line": 47,
          "function": "par_dinbrack"
        }
      },
      "simple": {
        "union": [
          {
            "repeat": {
              "union": [
                {
                  "$ref": "cmd"
                },
                {
                  "$ref": "list"
                },
                {
                  "$ref": "nl_wordlist"
                },
                {
                  "$ref": "redir"
                }
              ],
              "source": {
                "file": "parse.syms",
                "line": 48,
                "function": "par_simple"
              }
            },
            "min": 0,
            "description": "par_simple contains for loop with parser function calls",
            "source": {
              "file": "parse.syms",
              "line": 48,
              "function": "par_simple"
            }
          },
          {
            "variant": {
              "repeat": {
                "union": [
                  {
                    "$ref": "cmd"
                  },
                  {
                    "$ref": "list"
                  },
                  {
                    "$ref": "nl_wordlist"
                  },
                  {
                    "$ref": "redir"
                  }
                ],
                "source": {
                  "file": "parse.syms",
                  "line": 48,
                  "function": "par_simple"
                }
              },
              "min": 0,
              "description": "par_simple contains for loop with parser function calls",
              "source": {
                "file": "parse.syms",
                "line": 48,
                "function": "par_simple"
              }
            },
            "condition": {
              "lexstate": "INCMDPOS"
            },
            "description": "simple sets lexer state INCMDPOS",
            "source": {
              "file": "parse.c",
              "line": 1888,
              "function": "par_simple",
              "context": "sets INCMDPOS"
            }
          },
          {
            "variant": {
              "repeat": {
                "union": [
                  {
                    "$ref": "cmd"
                  },
                  {
                    "$ref": "list"
                  },
                  {
                    "$ref": "nl_wordlist"
                  },
                  {
                    "$ref": "redir"
                  }
                ],
                "source": {
                  "file": "parse.syms",
                  "line": 48,
                  "function": "par_simple"
                }
              },
              "min": 0,
              "description": "par_simple contains for loop with parser function calls",
              "source": {
                "file": "parse.syms",
                "line": 48,
                "function": "par_simple"
              }
            },
            "condition": {
              "lexstate": "INTYPESET"
            },
            "description": "simple sets lexer state INTYPESET",
            "source": {
              "file": "parse.c",
              "line": 1928,
              "function": "par_simple",
              "context": "sets INTYPESET"
            }
          }
        ],
        "description": "simple (modifies lexer states: INCMDPOS, INTYPESET)",
        "source": {
          "file": "parse.syms",
          "line": 48,
          "function": "par_simple"
        }
      },
      "redir": {
        "union": [
          {
            "pattern": "[redir]",
            "source": {
              "file": "parse.syms",
              "line": 49,
              "function": "par_redir"
            }
          },
          {
            "variant": {
              "pattern": "[redir]",
              "source": {
                "file": "parse.syms",
                "line": 49,
                "function": "par_redir"
              }
            },
            "condition": {
              "lexstate": "INCMDPOS"
            },
            "description": "redir sets lexer state INCMDPOS",
            "source": {
              "file": "parse.c",
              "line": 2225,
              "function": "par_redir",
              "context": "sets INCMDPOS"
            }
          }
        ],
        "description": "redir (modifies lexer states: INCMDPOS)",
        "source": {
          "file": "parse.syms",
          "line": 49,
          "function": "par_redir"
        }
      },
      "wordlist": {
        "pattern": "[wordlist]",
        "source": {
          "file": "parse.syms",
          "line": 51,
          "function": "par_wordlist"
        }
      },
      "nl_wordlist": {
        "pattern": "[nl_wordlist]",
        "source": {
          "file": "parse.syms",
          "line": 52,
          "function": "par_nl_wordlist"
        }
      },
      "cond_1": {
        "optional": {
          "$ref": "cond_2",
          "source": {
            "file": "parse.syms",
            "line": 55,
            "function": "par_cond_1"
          }
        },
        "description": "par_cond_1 contains if statement without else with parser function calls",
        "source": {
          "file": "parse.syms",
          "line": 55,
          "function": "par_cond_1"
        }
      },
      "cond_2": {
        "union": [
          {
            "optional": {
              "union": [
                {
                  "$ref": "cond"
                },
                {
                  "$ref": "cond_double"
                },
                {
                  "$ref": "cond_multi"
                },
                {
                  "$ref": "cond_triple"
                }
              ],
              "source": {
                "file": "parse.syms",
                "line": 56,
                "function": "par_cond_2"
              }
            },
            "description": "par_cond_2 contains if statement without else with parser function calls",
            "source": {
              "file": "parse.syms",
              "line": 56,
              "function": "par_cond_2"
            }
          },
          {
            "variant": {
              "optional": {
                "union": [
                  {
                    "$ref": "cond"
                  },
                  {
                    "$ref": "cond_double"
                  },
                  {
                    "$ref": "cond_multi"
                  },
                  {
                    "$ref": "cond_triple"
                  }
                ],
                "source": {
                  "file": "parse.syms",
                  "line": 56,
                  "function": "par_cond_2"
                }
              },
              "description": "par_cond_2 contains if statement without else with parser function calls",
              "source": {
                "file": "parse.syms",
                "line": 56,
                "function": "par_cond_2"
              }
            },
            "condition": {
              "lexstate": "INCMDPOS"
            },
            "description": "cond_2 sets lexer state INCMDPOS",
            "source": {
              "file": "parse.c",
              "line": 2530,
              "function": "par_cond_2",
              "context": "sets INCMDPOS"
            }
          },
          {
            "variant": {
              "optional": {
                "union": [
                  {
                    "$ref": "cond"
                  },
                  {
                    "$ref": "cond_double"
                  },
                  {
                    "$ref": "cond_multi"
                  },
                  {
                    "$ref": "cond_triple"
                  }
                ],
                "source": {
                  "file": "parse.syms",
                  "line": 56,
                  "function": "par_cond_2"
                }
              },
              "description": "par_cond_2 contains if statement without else with parser function calls",
              "source": {
                "file": "parse.syms",
                "line": 56,
                "function": "par_cond_2"
              }
            },
            "condition": {
              "lexstate": "INCOND"
            },
            "description": "cond_2 sets lexer state INCOND",
            "source": {
              "file": "parse.c",
              "line": 2588,
              "function": "par_cond_2",
              "context": "sets INCOND"
            }
          }
        ],
        "description": "cond_2 (modifies lexer states: INCMDPOS, INCOND)",
        "source": {
          "file": "parse.syms",
          "line": 56,
          "function": "par_cond_2"
        }
      },
      "cond_double": {
        "union": [
          {
            "pattern": "[cond_double]",
            "source": {
              "file": "parse.syms",
              "line": 57,
              "function": "par_cond_double"
            }
          },
          {
            "variant": {
              "pattern": "[cond_double]",
              "source": {
                "file": "parse.syms",
                "line": 57,
                "function": "par_cond_double"
              }
            },
            "condition": {
              "lexstate": "INCMDPOS"
            },
            "description": "cond_double sets lexer state INCMDPOS",
            "source": {
              "file": "parse.c",
              "line": 2615,
              "function": "par_cond_double",
              "context": "sets INCMDPOS"
            }
          }
        ],
        "description": "cond_double (modifies lexer states: INCMDPOS)",
        "source": {
          "file": "parse.syms",
          "line": 57,
          "function": "par_cond_double"
        }
      },
      "cond_triple": {
        "union": [
          {
            "pattern": "[cond_triple]",
            "source": {
              "file": "parse.syms",
              "line": 59,
              "function": "par_cond_triple"
            }
          },
          {
            "variant": {
              "pattern": "[cond_triple]",
              "source": {
                "file": "parse.syms",
                "line": 59,
                "function": "par_cond_triple"
              }
            },
            "condition": {
              "lexstate": "INCMDPOS"
            },
            "description": "cond_triple sets lexer state INCMDPOS",
            "source": {
              "file": "parse.c",
              "line": 2689,
              "function": "par_cond_triple",
              "context": "sets INCMDPOS"
            }
          }
        ],
        "description": "cond_triple (modifies lexer states: INCMDPOS)",
        "source": {
          "file": "parse.syms",
          "line": 59,
          "function": "par_cond_triple"
        }
      },
      "cond_multi": {
        "union": [
          {
            "pattern": "[cond_multi]",
            "source": {
              "file": "parse.syms",
              "line": 60,
              "function": "par_cond_multi"
            }
          },
          {
            "variant": {
              "pattern": "[cond_multi]",
              "source": {
                "file": "parse.syms",
                "line": 60,
                "function": "par_cond_multi"
              }
            },
            "condition": {
              "lexstate": "INCMDPOS"
            },
            "description": "cond_multi sets lexer state INCMDPOS",
            "source": {
              "file": "parse.c",
              "line": 2699,
              "function": "par_cond_multi",
              "context": "sets INCMDPOS"
            }
          }
        ],
        "description": "cond_multi (modifies lexer states: INCMDPOS)",
        "source": {
          "file": "parse.syms",
          "line": 60,
          "function": "par_cond_multi"
        }
      }
    }
  },
  "zsh_version": "5.9",
  "zsh_revision": "73d317384c9225e46d66444f93b46f0fbe7084ef"
}
